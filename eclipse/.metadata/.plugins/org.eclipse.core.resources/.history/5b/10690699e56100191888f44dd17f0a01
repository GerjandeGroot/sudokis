/*
 * Image.cpp
 *
 *  Created on: 17 apr. 2019
 *      Author: gerja
 */

#include "Image.h"

uint16_t map(uint16_t x, uint16_t in_max, uint16_t out_max) {
  return x * out_max / in_max;
}

Image::Image(uint16_t width, uint16_t height) {
	this->width = width;
	this->height = height;
	createData();
}

Image::~Image() {
	//delete[] imageData;
	printf("delete");
	free(imageData);
}

void Image::createData() {
	free(imageData);
	//delete[] imageData;
	//imageData = new uint8_t[(width*height)/8+1];
	//imageData = (uint8_t *) realloc(imageData,(width*height)/8+1);
	imageData = (uint8_t *) malloc((width*height)/8+1);
	if(imageData == NULL) printf("error");
}

void Image::clearImage() {
	for (int y = 0; y < height; ++y) {
		for (int x = 0; x < width; ++x) {
			setPixelRaw(x,y,1);
		}
	}
}

void Image::setPixel(uint16_t x, uint16_t y, uint8_t value) {
	if( ((value & (111<<4)) >> 4) > 6 || ((value & (111<<1)) >> 1) > 6 ) {
	//if (value == 0xFF) {
		imageData[(y*width + x) / 8] |= 1 << (y*width + x) % 8;
	} else {
		imageData[(y*width + x) / 8] &= ~(1 << (y*width + x) % 8);
	}
}

void Image::setPixelRaw(uint16_t x, uint16_t y, uint8_t value) {
	if (value) {
		imageData[(y*width + x) / 8] |= 1 << (y*width + x) % 8;
	} else {
		imageData[(y*width + x) / 8] &= ~(1 << (y*width + x) % 8);
	}
}

uint8_t Image::getPixel(uint16_t x, uint16_t y) {
	return imageData[(y*width + x) / 8] & 1 << ((y*width + x) % 8);
}

void Image::loadImage(const uint8_t * data) {
	for (int x = 0; x < width; ++x) {
		for (int y = 0; y < height; ++y) {
			uint8_t value = data[(x + y * (width))];
			setPixelRaw(x,y,value);
		};
	};
}

void Image::resize(uint16_t newWidth, uint16_t newHeight) {
	Image newImage = Image(newWidth, newHeight);
	double widthScale = (double)newWidth / (double)width;
	double heightScale = (double)newHeight / (double)height;

	double nx = 0;
	double ny = 0;
	if(widthScale < 1) {
		newImage.clearImage();

		for (int y = 0; y < height-1; ++y) {
			nx = 0;
			for (int x = 0; x < width-1; ++x) {
				if(!getPixel(x,y)) {
					if(!getPixel(x+1,y)) newImage.setPixelRaw(nx,ny,0);
					if(!getPixel(x,y+1)) newImage.setPixelRaw(nx,ny,0);
				}
				nx += widthScale;
			}
			ny += heightScale;
		}
		newImage.draw(0,0);
		clearScreen();
	}
	copy(&newImage);
}

void Image::copy(Image *newImage) {
	width = newImage->width;
	height = newImage->height;
	createData();

	for (int x = 0; x < width; ++x) {
		for (int y = 0; y < height; ++y) {
			setPixelRaw(x,y,newImage->getPixel(x,y));
		}
	}
}

void Image::draw(uint16_t x, uint16_t y) {
	for (int x = 0; x < width; ++x) {
		for (int y = 0; y < height; ++y) {
			drawPixel(x,y,getPixel(x,y));
		};
	};
}

Image Image::extract() {
	uint8_t xc[5000];
	uint8_t yc[5000];
	uint16_t pointer = 0;
	uint16_t checkedPointer = 0;
	uint16_t minX, minY, maxX, maxY;

	for (uint16_t x = 0; x < width; ++x) {
		for (uint16_t y = 0; y < height; ++y) {
			if(!getPixel(x,y)) {
				xc[pointer] = x;
				yc[pointer] = y;
				pointer++;
				minX = x;
				minY = y;
				maxX = x;
				maxY = y;
				x=width;
				y=height;
				setPixelRaw(x,y,1);
			}
		}
	}

	while (checkedPointer < pointer) {
		uint16_t x = xc[checkedPointer];
		uint16_t y = yc[checkedPointer];
		checkedPointer++;

		if(x < minX) minX = x;
		if(x > maxX) maxX = x;
		if(y < minY) minY = y;
		if(y > maxY) maxY = y;

		if (x < width-1) {
			if(!getPixel(x+1,y)) {
				xc[pointer] = x+1;
				yc[pointer] = y;
				pointer++;
				setPixelRaw(x+1,y,1);
			}
		}
		if (x > 0) {
			if(!getPixel(x-1,y)) {
				xc[pointer] = x-1;
				yc[pointer] = y;
				pointer++;
				setPixelRaw(x-1,y,1);
			}
		}
		if (y < height-1) {
			if(!getPixel(x,y+1)) {
				xc[pointer] = x;
				yc[pointer] = y+1;
				pointer++;
				setPixelRaw(x,y+1,1);
			}
		}
		if (y > 0) {
			if(!getPixel(x,y-1)) {
				xc[pointer] = x;
				yc[pointer] = y-1;
				pointer++;
				setPixelRaw(x,y-1,1);
			}
		}
		drawPixel(x,y,1);
	}
	Image image = Image(maxX-minX,maxY-minY);
	//image.clearImage();
	printf("%d\t%d\n",maxX-minX,maxY-minY);
	while(pointer > 0) {
		//printf("%d\n",pointer);
		pointer--;
		image.setPixelRaw(xc[pointer]-minX, yc[pointer],0-minY);
	}
	image.setPixelRaw(xc[0], yc[0],0);
	image.draw(0,0);
	return image;
}



